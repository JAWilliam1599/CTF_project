Use string format to overwrite the return address

we know that: if the payload

payload = 0x125894dc %64x%7$n

Suppose the leak that the variable that is used with printf(<variable>) (every other printf family) is at stack 7th argument
And 0x125894dc is pointed to 0x55cd3490

Then what the payload will do is that it will overwrite the value that 0x125894dc is pointed to, and change to 0x40 (64x)

So, the new value: 0x125894dc -> 0x00000040 ($n will overwrite 4 bytes)

Knowing the basic, we will start to leak some info from the binary file.

using file task and checksec --file=task, we know the file:
task: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, 
BuildID[sha1]=ae8fdb38ed7e6faced0d973c6dd2f7a8d8592ae1, for GNU/Linux 3.2.0, not stripped

RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH   
Full RELRO      Canary found      NX enabled    PIE enabled     No RPATH   No RUNPATH

Symbols         FORTIFY     Fortified       Fortifiable     FILE
51 Symbols      No          0               2               task

ELF 32 bits -> 4 bytes
dynamically linked -> can use GOT and PLT overwrite or ret2libc

Full RELRO means all linked library will be loaded at compile time -> GOT and PLT overwrite is impossible, also with ret2libc
Canary found means a special code is inserted before RBP -> harder to overflow buffer if we don't leak the Canary
NX enabled means that no executable stack, heap, and data section
PIE enabled means that each run time will allocate a different address for the binary file -> harder to exploit

So we can only use format string to attack and overwrite return address to point to victory.

task gives us addr of victory function, address of buf (address that points to stack) and address of return address

we extract the victory function, address of buf.

we need to find the addr that points to return address since we want to overwrite return address, we need to know the addr points to ret
we know the addr of buf, and buf is long 128 bytes so we plus 128 to end buf. we know 16 bytes is:
endbr64
Canary
padding
RBP

So in total, we have addr_buf + 144

we can overwrite the whole 4 bytes of ret but that is too large, 4 bytes means 32 bit -> 2,147 millons bytes printed out -> 2,14 GB

So we can split 2 bytes each to overwrite, since the addr can plus +2 to write at the high-order bytes

So, the payload will be:

payload = {ret} {ret + 2} %{lv}x%7$hn %{hv-lv}x%8$hn  (hv - lv since x will overwrite based on the number of bytes printed so far)

Note: 
- Since ret can contains \x00 which makes printf stop if meets so bring ret to the back
- Since PIE is on so hv can be larger than lv and vice versa so we should handle that (or run multiple times)
- When bring ret to the back, we need to ensure that the command is padding correctly (if not, ret will be overwrite to unwanted position and we overwrite to wrong addr)
- other arguments:
    + %l is 8 bytes
    + %n is 4 bytes
    + %hn is 2 bytes
    + %hhn is 1 bytes


flag: CTFlearn{d1r3c7_r3t_4ddr3ss_wr1t3}