We can not perform any overflows since read and fgets all take enough bytes.

Also, using checksec, we know that PIE, canary, NX is enabled which makes ROP or overflow become harder

However, there is a small exploitation:

First is getrandom, this function depends on the server we connect to, so if it is optimized for process to run at the
same location in memory or have gettime(null) then the pass will be the same each time.

However, better exploitation is at strncmp. This checks both str up to the length we want. And since the code take the
length from the input, so we want to take 2 bytes (1 bytes makes challenge tells pass is short) (brute force becomes possible)

However, memset makes the input already has 32 bytes, we will need to make the computer thinks that it only has 2 bytes by
using terminating null

So if we input something aa\x00 then we only need to check 2 bytes versus the password. If correct, we can get the flag

2 bytes, each bytes is from a to f, so we only need to try 36 combinations => feasible

flag: CTFlearn{7r1cky_nu11_by73s}