We will have these information to detect the problem we are dealing with

using file task, we know this is 64-bit ELF so we don't need to change interpreter.

using checksec, we know this file has canary, PIE and NX, which makes overflow buffer and shellcode hard.

Reading the code, we know that the flag is writing somewhere in the heap, this is important since we can perform string attack.

Lucky for us, it prints out the address of the pointer of flag so we can take that address and format the string to print it out in stack

We can do that by put in in buf and read out the string in the buf.

Firstly, we perform %p multiple times to see where is the buf. We know it is at argument 6th of stack

Secondly, create payload with the addr, %6$s and we can read out the string

However, we will meet an issue that the addr might not fully 8 bytes, and that means when it meets \x00, it will stop
and we can't see the string

So we swap the addr to the very end (to not meet \x00) and read the 7th argument
%6$s is 4 bytes so we add another 4 bytes to pad (b'AAAA')

So the final payload: payload = b''.join([b'%7$s', b'AAAA', int(addr, 16).tobytes(8, 'little')])

The flag: CTFlearn{ju57_4n_4rb17r4ry_r34d}